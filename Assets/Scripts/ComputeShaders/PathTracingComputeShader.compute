#pragma kernel CsMain

// region Constants
	SamplerState sampler_SkyboxTexture;
	static const float PI = 3.14159265f;
	static const float EPSILON = 1e-8;
	static const float MaxDistance = 9999999999999999999999999.0f;
// endregion 

// region Structs
	struct Sphere
	{
	    float3 position;
	    float radius;
	    float3 albedo;
	    float specular;
	    float smoothness;
	    float3 emission;
	    float refraction_index;
	};

	struct Plane
	{
        float3 normal;
        float3 position;
        float3 albedo;
        float specular;
        float smoothness;
        float3 emission;
		
	};

	struct Ray
	{
	    float3 origin;
	    float3 direction;
        float3 energy;
	};

    struct RayHit
    {
        float3 position;
        float distance;
        float3 normal;
        float3 albedo;
        float specular;
        float smoothness;
        float3 emission;
        bool inside;
        float refraction_index;

        float3 prev_position;
        bool prev_inside;
    };
// endregion

// region Exposed
	// RNG
	float2 _Pixel;
	float _Seed;

	// Basic Path tracing
	RWTexture2D<float4> _Result;
	float4x4 _CameraToWorld;
	float4x4 _CameraInverseProjection;
	Texture2D<float4> _SkyboxTexture;
	float2 _PixelOffset;

	// Primitives
	StructuredBuffer<Sphere> _Spheres;

	// Light
	float4 _DirectionalLight;
// endregion

// region Constructors
	Sphere TestSphere()
	{
	    Sphere sphere;

	    sphere.position = float3(0.0f, 20.0f, 0.0f);
	    sphere.radius = 5.0f;
	    sphere.albedo = float3(1.0f, 0.5f, 0.5f);
	    sphere.specular = 1.0f;
	    sphere.smoothness = 1.0f;
	    sphere.emission = float3(0.0f, 0.0f, 0.0f);
	    sphere.refraction_index = 1.333f;

	    return sphere;
	}

	Sphere TestSphere2()
	{
	    Sphere sphere;

	    sphere.position = float3(0.0f, 20.0f, 50.0f);
	    sphere.radius = 1.0f;
	    sphere.albedo = float3(1.0f, 0.5f, 0.5f);
	    sphere.specular = 1.0f;
	    sphere.smoothness = 1.0f;
	    sphere.emission = float3(0.0f, 0.0f, 0.0f);
	    sphere.refraction_index = 1.333f;

	    return sphere;
	}

	Plane CreateUnderground()
	{
        Plane plane;

        plane.normal = float3(0, -1, 0);
        plane.position = float3(0, -4, 0);
        plane.albedo = float3(.1f, .1f, .1f);
        plane.specular = 0.3f;
        plane.smoothness = 1.0f;
        plane.emission = float3(0.0f, 0.0f, 0.0f);

        return plane;
	}

	Ray CreateRay(float3 origin, float3 direction)
	{
	    Ray ray;
	    ray.origin = origin;
	    ray.direction = direction;
	    ray.energy = float3(1.0f, 1.0f, 1.0f);
	    return ray;
	}

	Ray CreateCameraRay(float2 uv)
	{
	    // Transform the camera origin to world space
	    const float3 origin = mul(_CameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;

	    // Invert the perspective projection of the view-space position
	    float3 direction = mul(_CameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;

	    // Transform the direction from camera to world space and normalize
	    direction = mul(_CameraToWorld, float4(direction, 0.0f)).xyz;
	    direction = normalize(direction);

	    return CreateRay(origin, direction);
	}

    RayHit CreateRayHit()
    {
        RayHit hit;

        hit.position = float3(0.0f, 0.0f, 0.0f);
        hit.distance = MaxDistance;
        hit.normal = float3(0.0f, 0.0f, 0.0f);
        hit.albedo = float3(0.0f, 1.0f, 0.0f);
        hit.specular = 0.0f;
        hit.smoothness = 0.0f;
        hit.emission = float3(0.0f, 1.0f, 0.0f);

        hit.inside = false;
        hit.refraction_index = 0.0f;

        hit.prev_position = float3(0.0f, 0.0f, 0.0f);
        hit.prev_inside = false;

        return hit;
    }
// endregion

// region HelperFunctions
	float Rand()
	{
		const float result = frac(sin(_Seed / 100.0f * dot(_Pixel, float2(12.9898f, 78.233f))) * 43758.5453f);
	    _Seed += 1.0f;
	    return result;
	}

	float SDot(const float3 x, const float3 y, const float f = 1.0f)
	{
	    return saturate(dot(x, y) * f);
	}

	float Energy(const float3 color)
	{
	    return dot(color, 1.0f / 3.0f);
	}
    
    float3x3 GetTangentSpace(float3 normal)
    {
        // Choose a helper vector for the cross product
        float3 helper = float3(1, 0, 0);
        if (abs(normal.x) > 0.99f)
            helper = float3(0, 0, 1);

        // Generate vectors
        float3 tangent = normalize(cross(normal, helper));
        float3 bi_normal = normalize(cross(normal, tangent));
        return float3x3(tangent, bi_normal, normal);
    }

    float3 SampleHemisphere(float3 normal, float alpha)
    {
        // Sample the hemisphere, where alpha determines the kind of the sampling
        float cos_theta = pow(Rand(), 1.0f / (alpha + 1.0f));
        const float sin_theta = sqrt(1.0f - cos_theta * cos_theta);
        const float phi = 2 * PI * Rand();
        const float3 tangent_space_dir = float3(cos(phi) * sin_theta, sin(phi) * sin_theta, cos_theta);

        // Transform direction to world space
        return mul(tangent_space_dir, GetTangentSpace(normal));
    }

    float SmoothnessToPhongAlpha(const float s)
    {
        return pow(1000.0f, s * s);
    }
// endregion

// region IntersectionLogic
	void IntersectPlane(Ray ray, inout RayHit best_hit, Plane plane)
	{
		const float denom = dot(plane.normal, ray.direction);
	    if (denom > 0.0000001f)
	    {
		    const float3 p_or_o = plane.position - ray.origin;
		    const float t = dot(p_or_o, plane.normal) / denom;

	        if (t > 0 && t < best_hit.distance)
	        {
	            best_hit.distance = t;
	            best_hit.position = ray.origin + t * ray.direction;
	            best_hit.normal = -1.0f * plane.normal;
                best_hit.albedo = plane.albedo;
                best_hit.specular = plane.specular;
                best_hit.smoothness = plane.smoothness;
                best_hit.emission = plane.emission;
	        }
	    }
	}

	void IntersectSphere(Ray ray, inout RayHit bestHit, Sphere sphere)
	{
	    // Calculate distance along the ray where the sphere is intersected
	    const float3 d = ray.origin - sphere.position;
	    const float p1 = -dot(ray.direction, d);
	    float p2 = p1 * p1 - dot(d, d) + sphere.radius * sphere.radius;
	    if (p2 < 0)
	        return;
	    p2 = sqrt(p2);
	    float t = p1 - p2;

	    const bool inside = t < 0;

	    if (inside)
	        t = p1 + p2;

	    if (t > 0 && t < bestHit.distance)
	    {
	        bestHit.distance = t;
	        bestHit.position = ray.origin + t * ray.direction;
	        bestHit.normal = normalize(bestHit.position - sphere.position);
	        bestHit.albedo = sphere.albedo;
	        bestHit.specular = sphere.specular;
	        bestHit.smoothness = sphere.smoothness;
	        bestHit.emission = sphere.emission;
	        
	        bestHit.inside = inside;
	        bestHit.refraction_index = sphere.refraction_index;

	    }
	}
// endregion

RayHit Trace(const Ray ray)
{
    RayHit best_hit = CreateRayHit();

    const Plane plane = CreateUnderground();
    IntersectPlane(ray, best_hit, plane);

    const Sphere sphere = TestSphere();
    IntersectSphere(ray, best_hit, sphere);

    const Sphere sphere2 = TestSphere2();
    IntersectSphere(ray, best_hit, sphere2);

    // Trace spheres
    uint num_spheres, stride;
    _Spheres.GetDimensions(num_spheres, stride);
    for (uint i = 0; i < num_spheres; i++)
        IntersectSphere(ray, best_hit, _Spheres[i]);
    
    return best_hit;
}

float3 Shade(inout Ray ray, RayHit hit)
{
    if (hit.distance < MaxDistance)
    {
        // Calculate chances of diffuse and specular reflection
        float spec_chance = Energy(hit.specular);
        float diff_chance = Energy(hit.albedo);
        const float sum = spec_chance + diff_chance;
        spec_chance /= sum;
        diff_chance /= sum;
        
        // Roulette-select the ray's path: This so the specular surface is not 100% reflective
        const float roulette = Rand();
        if (hit.refraction_index > 0.0f)
        {
            float3 n = hit.normal;
            float n1 = 1.0f;
            float n2 = hit.refraction_index;

            if(hit.inside)
            {
	            const float temp = n1;
                n1 = n2;
                n2 = temp;

                n = -1.0f * n;
            }

            float cos_theta_i = clamp(-1.0f, 1.0f, dot(n, -1.0f * ray.direction));
            const float n1_n2 = n1 / n2;
            const float sin_theta_t = n1_n2 * sqrt(max(0.0f, 1 - cos_theta_i * cos_theta_i));

            float refract_ratio = 1.0f;
            if(sin_theta_t < 1.0f)
            {
	            const float cos_theta_t = sqrt(max( 0.0f, 1.0f - sin_theta_t * sin_theta_t ) );
                cos_theta_i = abs( cos_theta_i );

	            const float rs = ( ( n2 * cos_theta_i ) - ( n1 * cos_theta_t ) ) / ( ( n2 * cos_theta_i ) + ( n1 * cos_theta_t ) );
	            const float rp = ( ( n1 * cos_theta_i ) - ( n2 * cos_theta_t ) ) / ( ( n1 * cos_theta_i ) + ( n2 * cos_theta_t ) );
                refract_ratio = ( rs * rs + rp * rp ) * 0.5f;
            }


            // Chance is [0, 1] -> If refractChance > 1 we always reflect
            const float refract_chance = Rand();
            if(refract_chance > refract_ratio)
            {
                // Refract
                if(hit.inside)
                {
	                const float d = distance(hit.position, hit.prev_position);

                    ray.energy.x *= exp( -hit.albedo.x / 10.0f * d);
                    ray.energy.y *= exp( -hit.albedo.y / 10.0f * d);
                    ray.energy.z *= exp( -hit.albedo.z / 10.0f * d);
                }
            
                // Calculate k
                const float k = 1 - (n1_n2 * n1_n2) * (1 - (cos_theta_i * cos_theta_i));
                if(k < 0)
                {
                    ray.direction = 0.0f;
                    ray.energy = 0.0f;
                    return float3(0.0f, 0.0f, 0.0f);
                }
                else
                {
                    ray.direction = n1_n2 * ray.direction + n * (n1_n2 * cos_theta_i - sqrt(k));
                    ray.origin = hit.position + ray.direction * 0.001f;
                    return hit.emission;
                }
            }
            else
            {
                // Reflect

                // Specular reflection
                const float alpha = SmoothnessToPhongAlpha(hit.smoothness);
                ray.direction = SampleHemisphere(reflect(ray.direction, hit.normal), alpha);
                const float f = (alpha + 2) / (alpha + 1);
                ray.energy *= (1.0f / spec_chance) * hit.specular * hit.albedo * SDot(hit.normal, ray.direction, f);
            }
        }
        else if (roulette < spec_chance)
        {
            // Specular reflection
            const float alpha = SmoothnessToPhongAlpha(hit.smoothness);
            ray.direction = SampleHemisphere(reflect(ray.direction, hit.normal), alpha);
            const float f = (alpha + 2) / (alpha + 1);
            ray.energy *= (1.0f / spec_chance) * hit.specular * SDot(hit.normal, ray.direction, f);
        }
        else
        { 
            // Diffuse reflection
            ray.direction = SampleHemisphere(hit.normal, 1.0f);
            ray.energy *= (1.0f / diff_chance) * hit.albedo;
        }
        
        ray.origin = hit.position + ray.direction * 0.001f;
        return hit.emission;
    }
    else
    {
        // Hit sky

        // Erase the ray's energy - the sky doesn't reflect anything
        ray.energy = 0.0f;
        
        // Sample the skybox and write it
        float theta = acos(ray.direction.y) / -PI;
        float phi = atan2(ray.direction.x, -ray.direction.z) / -PI * 0.5f;
        return _SkyboxTexture.SampleLevel(sampler_SkyboxTexture, float2(phi, theta), 0).xyz * 1.2;
    }
}

[numthreads(8, 8, 1)]
void CsMain(uint3 id : SV_DispatchThreadID)
{
    _Pixel = id.xy;
    
    // Get the dimensions of the RenderTexture
    uint width, height;
    _Result.GetDimensions(width, height);

    // Transform pixel to [-1,1] range
    const float2 uv = float2((id.xy + _PixelOffset) / float2(width, height) * 2.0f - 1.0f);

    // Get a ray for the UVs
    Ray ray = CreateCameraRay(uv);
    
    // Trace and shade
    float3 result = float3(0, 0, 0);
    bool prev_inside = false;
    float3 prev_position = float3(0.0f, 0.0f, 0.0f);
    for (int i = 0; i < 8; i++)
    {
        RayHit hit = Trace(ray);

        hit.prev_inside = prev_inside;
        hit.prev_position = prev_position;

        result += ray.energy * Shade(ray, hit);

        // Keep track of prev Pos for Beer's law
        prev_inside = hit.inside;
        prev_position = hit.position;

        if (!any(ray.energy))
            break;
    }

    _Result[id.xy] = float4(result, 1);
}